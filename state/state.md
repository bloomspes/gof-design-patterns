# State

### 의도

객체의 내부 상태에 따라 `스스로 행동을 변경할 수 있게 허가하는 패턴`으로, 이렇게 하면 객체는 마치 자신의 클래스를 바꾸는 것처럼 보입니다.  

### 동기

네트워크 연결을 추상화한 TCPConnection 클래스가 존재한다고 가정해 봅시다. TCPConnection 객체는 다른 객체에서 동일한 요청을 받을 때, 자신의 현재 상태에 따라 다르게 반응합니다.    
예를 들어, Open 요청은 연결 상태가 "연결 종료" 혹은 "연결 성공" 상태인지에 따라서 처리하는 결과가 다를 수 밖에 없죠.  

그러면 위의 클래스를 우리가 알고있는 디자인 패턴을 활용해서 어떻게 구현할 수 있을까요?

위의 사례를 구현한다고 했을 때, 네트워크 연결에서 나타나는 모든 상태를 표현하는 TCPState `추상 클래스`를 도입할 수 있습니다.  

여기서, TCPState 추상 클래스는 서로 다른 운영상태를 표현할 다른 `모든 서브클래스에 공통되는 인터페이스`를 `정의` 합니다.

TCPConnection 클래스는 현재 TCP 연결 상태를 표현하는 TCPState `객체`를 내부에 유지합니다.  

이 `상태 객체`로 TCPConnection 클래스의 현재 상태를 파악할 수 있는 것이죠.  

이 후에 TCPConnection 클래스는 상태에 따라 달라지는 `연산의 처리`를 상태 객체 쪽으로 미룹니다. 

### 언제, 사용할 수 있을까?

- `객체`의 `행동`이 `상태`에 따라 달라질 수 있고, `객체`의 `상태`에 따라서 `런타임`에 `행동`이 바뀌어야 합니다. 

- 어떤 연산에 객체의 상태에 따라 달라지는 처리가 너무 많이 들어있는 경우에도 `객체의 상태`를 별도의 `객체`로 `정의` 하면 응용할 수 있습니다. 

### 참여자

- Context (TCPConnection)
- State (TCPState)
- ConcreteState (TCPListen, TCPClosed 같은 서브클래스들)

### State 패턴 구현에 고려해야 하는 것들

![](https://4z7l.github.io/images/pattern/state/uml.svg)

1. 누가 상태 전이를 정할 것인가?
- 상태 패턴에서는 상태 전이를 책임질 수 있는 참여자(객체)가 존재해야 한다.

2. 테이블 기반의 대안
- (C++ Programming Style 참조) 입력 값과 상태 전이를 매핑하는 방법을 사용함, 각 상태마다 테이블을 사용하여 그 상태에서 처리 가능한 입력과 그 입력으로 생길 수 있는 다음 상태를 매핑하는 방법.

3. 상태 객체의 생성과 소멸
- 구현할 때 가장 흔히 생각하는 선택 사항은 상태 객체를 `필요할 때만 생성하고 필요 없게 되면 없앨 것인지?` 혹은 `필요하기 전에 미리 만들어 둔 후 없애지 않고 계속 둘 것인지`에 대한 선택입니다.  

- 첫 번째 방법의 경우, State 객체가 많은 정보를 담고 있는 경우라면 매우 유용한 해법이 될 수 있다.

- 두 번째 방법의 경우, 상태 변화가 수시로 일어날 때 객체의 생성과 삭제를 반복할 필요가 없으므로 훨씬 좋은 방법이 되겠죠. 하지만 모든 상태에 대한 참조자를 계속 관리해야 하는 부담이 생길 수 있습니다.

4. 동적 상속을 이용하는 방법

- 어떤 특정 요청에 따라 행동을 바꾸려면 런타임에 객체가 클래스를 변경하는 것으로 해결되지 않을까.  


### State 패턴을 사용했을 때 기대할 수 있는 것들

1. 상태에 따른 행동을 국소화 하며, 서로 다른 상태에 대한 행동을 별도의 객체로 관리합니다.

- 상태 패턴을 사용하면 한 상태(State)에 관련된 모든 행동을 하나의 객체로 모을 수 있습니다. 한 상태에 종속적인 코드를 State 클래스의 서브클래스에 모두 정의하므로 새로운 상태나 전이가 발견되면 새로운 서브클래스를 정의하면 됩니다. 

- 상태 패턴은 대량의 조건문으로 상태를 판별하는 문제점을 해결 할 수 있는 해법입니다.

2. 상태 전이를 명확하게 만듭니다.

- 어떤 객체가 자신의 현재 상태를 오직 내부 데이터 값으로만 정의하면, 상태 전이는 표현이 모호해집니다.

- 각 상태별로 객체를 만드는 일은 상태 전이를 명확하게 표현해주는 결과가 됩니다. 상태는 여러 개의 변수가 아니라, 하나의 변수, Context의 State 객체 변수를 리바인딩 함으로써 전이될 뿐입니다.

3. 상태 객체는 공유될 수 있습니다.


